#include <windows.h>
#include <commdlg.h>
#include <commctrl.h>
#include <vector>
#include <string>
#include <fstream>
#include <sstream>
#include <algorithm>
#include <cmath>
#include <map>
#include <set>

#pragma comment(lib, "comctl32.lib")
#pragma comment(lib, "comdlg32.lib")
#pragma execution_character_set("utf-8")

// –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
#define ID_LOAD_BUTTON 1001
#define ID_CALCULATE_BUTTON 1002
#define ID_SAVE_BUTTON 1003
#define ID_COLUMN_LIST 1004
#define ID_TARGET_COMBO 1005
#define ID_LAMBDA_EDIT 1007
#define ID_RESULTS_EDIT 1008
#define ID_METHOD_OLS 1009
#define ID_METHOD_RIDGE 1010
#define ID_METHOD_HUBER 1011
#define ID_METHOD_WEIGHTED 1012

// –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
HWND hMainWindow;
HWND hLoadButton, hCalculateButton, hSaveButton;
HWND hColumnList, hTargetCombo, hLambdaEdit;
HWND hResultsEdit;
HWND hMethodOLS, hMethodRidge, hMethodHuber, hMethodWeighted;
std::vector<std::vector<std::string>> data;
std::vector<std::string> columnNames;
std::string resultsText;

// –°—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö
struct RegressionResult {
    std::vector<double> coefficients;
    double r_squared;
    double mape;
    std::vector<double> predictions;
    std::vector<double> residuals;
};

// –£—Ç–∏–ª–∏—Ç—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å–æ —Å—Ç—Ä–æ–∫–∞–º–∏
std::wstring StringToWString(const std::string& str) {
    if (str.empty()) return std::wstring();
    int size_needed = MultiByteToWideChar(CP_UTF8, 0, &str[0], (int)str.size(), NULL, 0);
    std::wstring wstrTo(size_needed, 0);
    MultiByteToWideChar(CP_UTF8, 0, &str[0], (int)str.size(), &wstrTo[0], size_needed);
    return wstrTo;
}

std::string WStringToString(const std::wstring& wstr) {
    if (wstr.empty()) return std::string();
    int size_needed = WideCharToMultiByte(CP_UTF8, 0, &wstr[0], (int)wstr.size(), NULL, 0, NULL, NULL);
    std::string strTo(size_needed, 0);
    WideCharToMultiByte(CP_UTF8, 0, &wstr[0], (int)wstr.size(), &strTo[0], size_needed, NULL, NULL);
    return strTo;
}

// –ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ —É—Ç–∏–ª–∏—Ç—ã
class MathUtils {
public:
    static std::vector<std::vector<double>> matrixMultiply(
        const std::vector<std::vector<double>>& A,
        const std::vector<std::vector<double>>& B) {

        size_t rows_A = A.size();
        size_t cols_A = A[0].size();
        size_t cols_B = B[0].size();

        std::vector<std::vector<double>> result(rows_A, std::vector<double>(cols_B, 0.0));

        for (size_t i = 0; i < rows_A; i++) {
            for (size_t j = 0; j < cols_B; j++) {
                for (size_t k = 0; k < cols_A; k++) {
                    result[i][j] += A[i][k] * B[k][j];
                }
            }
        }
        return result;
    }

    static std::vector<std::vector<double>> transpose(const std::vector<std::vector<double>>& matrix) {
        size_t rows = matrix.size();
        size_t cols = matrix[0].size();
        std::vector<std::vector<double>> result(cols, std::vector<double>(rows));

        for (size_t i = 0; i < rows; i++) {
            for (size_t j = 0; j < cols; j++) {
                result[j][i] = matrix[i][j];
            }
        }
        return result;
    }

    static std::vector<std::vector<double>> inverse(const std::vector<std::vector<double>>& matrix) {
        size_t n = matrix.size();
        std::vector<std::vector<double>> augmented(n, std::vector<double>(2 * n, 0.0));

        // –°–æ–∑–¥–∞–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—É—é –º–∞—Ç—Ä–∏—Ü—É [A|I]
        for (size_t i = 0; i < n; i++) {
            for (size_t j = 0; j < n; j++) {
                augmented[i][j] = matrix[i][j];
            }
            augmented[i][i + n] = 1.0;
        }

        // –ü—Ä—è–º–æ–π —Ö–æ–¥ –º–µ—Ç–æ–¥–∞ –ì–∞—É—Å—Å–∞
        for (size_t i = 0; i < n; i++) {
            // –ü–æ–∏—Å–∫ –≥–ª–∞–≤–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞
            size_t maxRow = i;
            for (size_t k = i + 1; k < n; k++) {
                if (abs(augmented[k][i]) > abs(augmented[maxRow][i])) {
                    maxRow = k;
                }
            }
            std::swap(augmented[i], augmented[maxRow]);

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –≤—ã—Ä–æ–∂–¥–µ–Ω–Ω–æ—Å—Ç—å
            if (abs(augmented[i][i]) < 1e-10) {
                throw std::runtime_error("–ú–∞—Ç—Ä–∏—Ü–∞ –≤—ã—Ä–æ–∂–¥–µ–Ω–∞");
            }

            // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç—Ä–æ–∫–∏
            double pivot = augmented[i][i];
            for (size_t j = 0; j < 2 * n; j++) {
                augmented[i][j] /= pivot;
            }

            // –û–±–Ω—É–ª–µ–Ω–∏–µ —Å—Ç–æ–ª–±—Ü–∞
            for (size_t k = 0; k < n; k++) {
                if (k != i) {
                    double factor = augmented[k][i];
                    for (size_t j = 0; j < 2 * n; j++) {
                        augmented[k][j] -= factor * augmented[i][j];
                    }
                }
            }
        }

        // –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –æ–±—Ä–∞—Ç–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã
        std::vector<std::vector<double>> result(n, std::vector<double>(n));
        for (size_t i = 0; i < n; i++) {
            for (size_t j = 0; j < n; j++) {
                result[i][j] = augmented[i][j + n];
            }
        }

        return result;
    }

    static double pearsonCorrelation(const std::vector<double>& x, const std::vector<double>& y) {
        size_t n = x.size();
        double sum_x = 0, sum_y = 0, sum_xy = 0, sum_x2 = 0, sum_y2 = 0;

        for (size_t i = 0; i < n; i++) {
            sum_x += x[i];
            sum_y += y[i];
            sum_xy += x[i] * y[i];
            sum_x2 += x[i] * x[i];
            sum_y2 += y[i] * y[i];
        }

        double numerator = n * sum_xy - sum_x * sum_y;
        double denominator = sqrt((n * sum_x2 - sum_x * sum_x) * (n * sum_y2 - sum_y * sum_y));

        return (denominator != 0) ? numerator / denominator : 0;
    }
};

// –ö–ª–∞—Å—Å –¥–ª—è –ø—Ä–µ–¥–æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö
class DataPreprocessor {
public:
    static std::vector<double> handleMissingValues(const std::vector<double>& column) {
        std::vector<double> validValues;
        for (double val : column) {
            if (!std::isnan(val)) {
                validValues.push_back(val);
            }
        }

        if (validValues.empty()) return column;

        // –í—ã—á–∏—Å–ª—è–µ–º –º–µ–¥–∏–∞–Ω—É
        std::sort(validValues.begin(), validValues.end());
        double median = validValues[validValues.size() / 2];

        std::vector<double> result = column;
        for (double& val : result) {
            if (std::isnan(val)) {
                val = median;
            }
        }

        return result;
    }

    static std::vector<double> removeOutliers(const std::vector<double>& column) {
        std::vector<double> sorted = column;
        std::sort(sorted.begin(), sorted.end());

        size_t n = sorted.size();
        double q1 = sorted[n / 4];
        double q3 = sorted[3 * n / 4];
        double iqr = q3 - q1;
        double lower_bound = q1 - 1.5 * iqr;
        double upper_bound = q3 + 1.5 * iqr;

        double median = sorted[n / 2];

        std::vector<double> result = column;
        for (double& val : result) {
            if (val < lower_bound || val > upper_bound) {
                val = median;
            }
        }

        return result;
    }

    static std::vector<double> normalize(const std::vector<double>& column) {
        double min_val = *std::min_element(column.begin(), column.end());
        double max_val = *std::max_element(column.begin(), column.end());

        std::vector<double> result;
        for (double val : column) {
            if (max_val != min_val) {
                result.push_back((val - min_val) / (max_val - min_val));
            }
            else {
                result.push_back(0.0);
            }
        }

        return result;
    }
};

// –ö–ª–∞—Å—Å –¥–ª—è –æ—Ç–±–æ—Ä–∞ –ø—Ä–∏–∑–Ω–∞–∫–æ–≤
class FeatureSelector {
public:
    static std::vector<int> selectSignificantFeatures(
        const std::vector<std::vector<double>>& features,
        const std::vector<double>& target,
        double threshold = 0.05) {  // –°–Ω–∏–∂–∞–µ–º –ø–æ—Ä–æ–≥ —Å 0.1 –¥–æ 0.05

        std::vector<std::pair<int, double>> correlations;

        for (size_t i = 0; i < features.size(); i++) {
            double correlation = abs(MathUtils::pearsonCorrelation(features[i], target));
            correlations.push_back({ (int)i, correlation });
        }

        // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —É–±—ã–≤–∞–Ω–∏—é –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–∏
        std::sort(correlations.begin(), correlations.end(),
            [](const std::pair<int, double>& a, const std::pair<int, double>& b) {
                return a.second > b.second;
            });

        std::vector<int> significant;

        // –ë–µ—Ä–µ–º –ø—Ä–∏–∑–Ω–∞–∫–∏ –≤—ã—à–µ –ø–æ—Ä–æ–≥–∞
        for (const auto& pair : correlations) {
            if (pair.second >= threshold) {
                significant.push_back(pair.first);
            }
        }

        // –ï—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ, –±–µ—Ä–µ–º —Ç–æ–ø-3 –ª—É—á—à–∏—Ö –ø—Ä–∏–∑–Ω–∞–∫–∞
        if (significant.empty() && !correlations.empty()) {
            size_t count = std::min<size_t>(3, correlations.size());
            for (int i = 0; i < count; i++) {
                significant.push_back(correlations[i].first);
            }
        }

        return significant;
    }

    static std::vector<int> removeMulticollinearity(
        const std::vector<std::vector<double>>& features,
        const std::vector<int>& indices,
        double threshold = 0.9) {  // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –ø–æ—Ä–æ–≥ —Å 0.8 –¥–æ 0.9

        if (indices.size() <= 1) return indices;  // –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É

        std::vector<int> result = indices;
        std::set<int> toRemove;

        for (size_t i = 0; i < result.size(); i++) {
            for (size_t j = i + 1; j < result.size(); j++) {
                double correlation = abs(MathUtils::pearsonCorrelation(
                    features[result[i]], features[result[j]]));
                if (correlation > threshold) {
                    // –£–¥–∞–ª—è–µ–º –ø—Ä–∏–∑–Ω–∞–∫ —Å –º–µ–Ω—å—à–µ–π –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–µ–π –∫ —Ü–µ–ª–µ–≤–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π
                    toRemove.insert(result[j]);
                }
            }
        }

        result.erase(std::remove_if(result.begin(), result.end(),
            [&toRemove](int idx) { return toRemove.count(idx) > 0; }), result.end());

        // –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º, —á—Ç–æ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω –ø—Ä–∏–∑–Ω–∞–∫ –æ—Å—Ç–∞–Ω–µ—Ç—Å—è
        if (result.empty() && !indices.empty()) {
            result.push_back(indices[0]);
        }

        return result;
    }
};

// –ö–ª–∞—Å—Å –º–æ–¥–µ–ª–∏ —Ä–µ–≥—Ä–µ—Å—Å–∏–∏
class RegressionModel {
private:
    std::vector<double> coefficients;

public:
    RegressionResult fit(const std::vector<std::vector<double>>& X, const std::vector<double>& y,
        const std::string& method = "OLS", double lambda = 0.01) {

        size_t n = X[0].size(); // –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–∞–±–ª—é–¥–µ–Ω–∏–π
        size_t p = X.size();    // –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–∏–∑–Ω–∞–∫–æ–≤

        // –î–æ–±–∞–≤–ª—è–µ–º —Å—Ç–æ–ª–±–µ—Ü –µ–¥–∏–Ω–∏—Ü –¥–ª—è —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ —á–ª–µ–Ω–∞
        std::vector<std::vector<double>> X_with_intercept(p + 1, std::vector<double>(n));
        for (size_t i = 0; i < n; i++) {
            X_with_intercept[0][i] = 1.0; // —Å–≤–æ–±–æ–¥–Ω—ã–π —á–ª–µ–Ω
            for (size_t j = 0; j < p; j++) {
                X_with_intercept[j + 1][i] = X[j][i];
            }
        }

        // –¢—Ä–∞–Ω—Å–ø–æ–Ω–∏—Ä—É–µ–º –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞ –≤—ã—á–∏—Å–ª–µ–Ω–∏–π
        std::vector<std::vector<double>> X_T = MathUtils::transpose(X_with_intercept);
        std::vector<std::vector<double>> X_matrix = MathUtils::transpose(X_T);

        // –í—ã—á–∏—Å–ª—è–µ–º X^T * X
        std::vector<std::vector<double>> XTX = MathUtils::matrixMultiply(X_matrix, X_T);

        // –î–ª—è Ridge —Ä–µ–≥—Ä–µ—Å—Å–∏–∏ –¥–æ–±–∞–≤–ª—è–µ–º —Ä–µ–≥—É–ª—è—Ä–∏–∑–∞—Ü–∏—é
        if (method == "Ridge") {
            for (size_t i = 1; i < XTX.size(); i++) { // –Ω–µ —Ä–µ–≥—É–ª—è—Ä–∏–∑—É–µ–º —Å–≤–æ–±–æ–¥–Ω—ã–π —á–ª–µ–Ω
                XTX[i][i] += lambda;
            }
        }

        try {
            // –í—ã—á–∏—Å–ª—è–µ–º (X^T * X)^(-1)
            std::vector<std::vector<double>> XTX_inv = MathUtils::inverse(XTX);

            // –í—ã—á–∏—Å–ª—è–µ–º X^T * y
            std::vector<double> XTy(p + 1, 0.0);
            for (size_t i = 0; i < p + 1; i++) {
                for (size_t j = 0; j < n; j++) {
                    XTy[i] += X_with_intercept[i][j] * y[j];
                }
            }

            // –í—ã—á–∏—Å–ª—è–µ–º –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã: beta = (X^T * X)^(-1) * X^T * y
            coefficients.resize(p + 1);
            for (size_t i = 0; i < p + 1; i++) {
                coefficients[i] = 0.0;
                for (size_t j = 0; j < p + 1; j++) {
                    coefficients[i] += XTX_inv[i][j] * XTy[j];
                }
            }

        }
        catch (const std::exception&) {
            // –ï—Å–ª–∏ –º–∞—Ç—Ä–∏—Ü–∞ –Ω–µ–æ–±—Ä–∞—Ç–∏–º–∞, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–æ—Å—Ç–æ–π –º–µ—Ç–æ–¥
            coefficients.resize(p + 1, 0.0);
        }

        // –í—ã—á–∏—Å–ª—è–µ–º –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è
        std::vector<double> predictions(n);
        for (size_t i = 0; i < n; i++) {
            predictions[i] = coefficients[0]; // —Å–≤–æ–±–æ–¥–Ω—ã–π —á–ª–µ–Ω
            for (size_t j = 0; j < p; j++) {
                predictions[i] += coefficients[j + 1] * X[j][i];
            }
        }

        // –í—ã—á–∏—Å–ª—è–µ–º –æ—Å—Ç–∞—Ç–∫–∏
        std::vector<double> residuals(n);
        for (size_t i = 0; i < n; i++) {
            residuals[i] = y[i] - predictions[i];
        }

        // –í—ã—á–∏—Å–ª—è–µ–º R¬≤
        double y_mean = 0.0;
        for (double val : y) y_mean += val;
        y_mean /= n;

        double ss_tot = 0.0, ss_res = 0.0;
        for (size_t i = 0; i < n; i++) {
            ss_tot += (y[i] - y_mean) * (y[i] - y_mean);
            ss_res += residuals[i] * residuals[i];
        }

        double r_squared = 1.0 - (ss_res / ss_tot);

        // –í—ã—á–∏—Å–ª—è–µ–º MAPE
        double mape = 0.0;
        int valid_count = 0;
        for (size_t i = 0; i < n; i++) {
            if (abs(y[i]) > 1e-10) {
                mape += abs(residuals[i] / y[i]);
                valid_count++;
            }
        }
        mape = (valid_count > 0) ? (mape / valid_count) * 100.0 : 0.0;

        RegressionResult result;
        result.coefficients = coefficients;
        result.r_squared = r_squared;
        result.mape = mape;
        result.predictions = predictions;
        result.residuals = residuals;

        return result;
    }
};

// –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ñ–∞–π–ª–∞–º–∏
std::vector<std::string> split(const std::string& str, char delimiter) {
    std::vector<std::string> tokens;
    std::stringstream ss(str);
    std::string token;

    while (std::getline(ss, token, delimiter)) {
        tokens.push_back(token);
    }

    return tokens;
}

bool loadCSVFile(const std::string& filename) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        return false;
    }

    data.clear();
    columnNames.clear();

    std::string line;
    bool first_line = true;

    while (std::getline(file, line)) {
        std::vector<std::string> row = split(line, ',');

        if (first_line) {
            columnNames = row;
            data.resize(row.size());
            first_line = false;
        }
        else {
            for (size_t i = 0; i < row.size() && i < data.size(); i++) {
                data[i].push_back(row[i]);
            }
        }
    }

    file.close();
    return true;
}

// –§—É–Ω–∫—Ü–∏–∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
void UpdateColumnList() {
    SendMessage(hColumnList, LB_RESETCONTENT, 0, 0);
    SendMessage(hTargetCombo, CB_RESETCONTENT, 0, 0);

    for (const std::string& name : columnNames) {
        std::wstring wname = StringToWString(name);
        SendMessage(hColumnList, LB_ADDSTRING, 0, (LPARAM)wname.c_str());
        SendMessage(hTargetCombo, CB_ADDSTRING, 0, (LPARAM)wname.c_str());
    }
}

void LoadFile() {
    OPENFILENAME ofn;
    wchar_t szFile[260] = { 0 };

    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hMainWindow;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = sizeof(szFile) / sizeof(wchar_t);
    ofn.lpstrFilter = L"CSV Files\0*.csv\0Excel Files\0*.xlsx\0All Files\0*.*\0";
    ofn.nFilterIndex = 1;
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;

    if (GetOpenFileName(&ofn)) {
        std::string filename = WStringToString(szFile);
        if (loadCSVFile(filename)) {
            UpdateColumnList();
            MessageBox(hMainWindow, L"–§–∞–π–ª —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω!", L"–£—Å–ø–µ—Ö", MB_OK | MB_ICONINFORMATION);
        }
        else {
            MessageBox(hMainWindow, L"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞!", L"–û—à–∏–±–∫–∞", MB_OK | MB_ICONERROR);
        }
    }
}

std::vector<std::string> getSelectedMethods() {
    std::vector<std::string> methods;

    if (SendMessage(hMethodOLS, BM_GETCHECK, 0, 0) == BST_CHECKED) {
        methods.push_back("OLS");
    }
    if (SendMessage(hMethodRidge, BM_GETCHECK, 0, 0) == BST_CHECKED) {
        methods.push_back("Ridge");
    }
    if (SendMessage(hMethodHuber, BM_GETCHECK, 0, 0) == BST_CHECKED) {
        methods.push_back("Huber");
    }
    if (SendMessage(hMethodWeighted, BM_GETCHECK, 0, 0) == BST_CHECKED) {
        methods.push_back("Weighted");
    }

    return methods;
}

void CalculateRegression() {
    if (data.empty()) {
        MessageBox(hMainWindow, L"–°–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∑–∏—Ç–µ —Ñ–∞–π–ª —Å –¥–∞–Ω–Ω—ã–º–∏!", L"–û—à–∏–±–∫–∞", MB_OK | MB_ICONWARNING);
        return;
    }

    // –ü–æ–ª—É—á–∞–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã–µ —Å—Ç–æ–ª–±—Ü—ã
    std::vector<int> selectedColumns;
    int count = (int)SendMessage(hColumnList, LB_GETCOUNT, 0, 0);
    for (int i = 0; i < count; i++) {
        if (SendMessage(hColumnList, LB_GETSEL, i, 0) > 0) {
            selectedColumns.push_back(i);
        }
    }

    if (selectedColumns.size() < 2) {
        MessageBox(hMainWindow, L"–í—ã–±–µ—Ä–∏—Ç–µ –º–∏–Ω–∏–º—É–º 2 —Å—Ç–æ–ª–±—Ü–∞ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞!", L"–û—à–∏–±–∫–∞", MB_OK | MB_ICONWARNING);
        return;
    }

    // –ü–æ–ª—É—á–∞–µ–º —Ü–µ–ª–µ–≤—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é
    int targetIndex = (int)SendMessage(hTargetCombo, CB_GETCURSEL, 0, 0);
    if (targetIndex == CB_ERR) {
        MessageBox(hMainWindow, L"–í—ã–±–µ—Ä–∏—Ç–µ —Ü–µ–ª–µ–≤—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é!", L"–û—à–∏–±–∫–∞", MB_OK | MB_ICONWARNING);
        return;
    }

    // –ü–æ–ª—É—á–∞–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã–µ –º–µ—Ç–æ–¥—ã
    std::vector<std::string> selectedMethods = getSelectedMethods();
    if (selectedMethods.empty()) {
        MessageBox(hMainWindow, L"–í—ã–±–µ—Ä–∏—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω –º–µ—Ç–æ–¥ —Ä–µ–≥—Ä–µ—Å—Å–∏–∏!", L"–û—à–∏–±–∫–∞", MB_OK | MB_ICONWARNING);
        return;
    }

    // –ü–æ–ª—É—á–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    wchar_t lambdaText[100];
    GetWindowText(hLambdaEdit, lambdaText, sizeof(lambdaText) / sizeof(wchar_t));
    std::string lambdaStr = WStringToString(lambdaText);
    double lambda = atof(lambdaStr.c_str());
    if (lambda <= 0) lambda = 0.01;

    try {
        // –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ
        std::vector<std::vector<double>> features;
        std::vector<double> target;

        // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º —Ü–µ–ª–µ–≤—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é
        for (const std::string& val : data[targetIndex]) {
            try {
                target.push_back(std::stod(val));
            }
            catch (...) {
                target.push_back(0.0);
            }
        }

        // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –ø—Ä–∏–∑–Ω–∞–∫–∏
        for (int colIdx : selectedColumns) {
            if (colIdx != targetIndex) {
                std::vector<double> feature;
                for (const std::string& val : data[colIdx]) {
                    try {
                        feature.push_back(std::stod(val));
                    }
                    catch (...) {
                        feature.push_back(0.0);
                    }
                }

                // –ü—Ä–µ–¥–æ–±—Ä–∞–±–æ—Ç–∫–∞
                feature = DataPreprocessor::handleMissingValues(feature);
                feature = DataPreprocessor::removeOutliers(feature);
                feature = DataPreprocessor::normalize(feature);

                features.push_back(feature);
            }
        }

        if (features.empty()) {
            MessageBox(hMainWindow, L"–ù–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞!", L"–û—à–∏–±–∫–∞", MB_OK | MB_ICONERROR);
            return;
        }

        // –û—Ç–±–æ—Ä –∑–Ω–∞—á–∏–º—ã—Ö –ø—Ä–∏–∑–Ω–∞–∫–æ–≤
        std::vector<int> significantIndices = FeatureSelector::selectSignificantFeatures(features, target, 0.05);
        significantIndices = FeatureSelector::removeMulticollinearity(features, significantIndices, 0.9);

        if (significantIndices.empty()) {
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –±–æ–ª–µ–µ –ø–æ–¥—Ä–æ–±–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ—à–∏–±–∫–µ
            std::stringstream errorMsg;
            errorMsg << "–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –ø–æ–¥—Ö–æ–¥—è—â–∏–µ –ø—Ä–∏–∑–Ω–∞–∫–∏ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞.\n\n";
            errorMsg << "–í–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã:\n";
            errorMsg << "‚Ä¢ –°–ª–∞–±–∞—è –∫–æ—Ä—Ä–µ–ª—è—Ü–∏—è –º–µ–∂–¥—É –ø—Ä–∏–∑–Ω–∞–∫–∞–º–∏ –∏ —Ü–µ–ª–µ–≤–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π\n";
            errorMsg << "‚Ä¢ –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞\n";
            errorMsg << "‚Ä¢ –ü—Ä–æ–±–ª–µ–º—ã —Å –∫–∞—á–µ—Å—Ç–≤–æ–º –¥–∞–Ω–Ω—ã—Ö\n\n";
            errorMsg << "–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:\n";
            errorMsg << "‚Ä¢ –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å –≤—ã–±–æ—Ä–∞ —Ü–µ–ª–µ–≤–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π\n";
            errorMsg << "‚Ä¢ –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –¥–∞–Ω–Ω—ã–µ —Å–æ–¥–µ—Ä–∂–∞—Ç —á–∏—Å–ª–æ–≤—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è\n";
            errorMsg << "‚Ä¢ –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –≤—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥–∏–µ —Å—Ç–æ–ª–±—Ü—ã –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞";

            std::wstring wErrorMsg = StringToWString(errorMsg.str());
            MessageBox(hMainWindow, wErrorMsg.c_str(), L"–ü—Ä–æ–±–ª–µ–º–∞ —Å –¥–∞–Ω–Ω—ã–º–∏", MB_OK | MB_ICONWARNING);
            return;
        }

        // –§–∏–ª—å—Ç—Ä—É–µ–º –ø—Ä–∏–∑–Ω–∞–∫–∏
        std::vector<std::vector<double>> filteredFeatures;
        for (int idx : significantIndices) {
            filteredFeatures.push_back(features[idx]);
        }

        // –§–æ—Ä–º–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –¥–ª—è –≤—Å–µ—Ö –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –º–µ—Ç–æ–¥–æ–≤
        std::stringstream ss;
        ss << "=== –†–ï–ó–£–õ–¨–¢–ê–¢–´ –ú–ù–û–ñ–ï–°–¢–í–ï–ù–ù–û–ô –†–ï–ì–†–ï–°–°–ò–ò ===\r\n\r\n";
        ss << "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–∏–∑–Ω–∞–∫–æ–≤: " << filteredFeatures.size() << "\r\n";
        ss << "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–∞–±–ª—é–¥–µ–Ω–∏–π: " << target.size() << "\r\n";
        ss << "–ü–∞—Ä–∞–º–µ—Ç—Ä lambda: " << lambda << "\r\n\r\n";

        // –û–±—É—á–∞–µ–º –º–æ–¥–µ–ª–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –º–µ—Ç–æ–¥–∞
        for (const std::string& method : selectedMethods) {
            RegressionModel model;
            RegressionResult result = model.fit(filteredFeatures, target, method, lambda);

            ss << "=== –ú–ï–¢–û–î: " << method << " ===\r\n";
            ss << "–ö–û–≠–§–§–ò–¶–ò–ï–ù–¢–´ –ú–û–î–ï–õ–ò:\r\n";
            ss << "–°–≤–æ–±–æ–¥–Ω—ã–π —á–ª–µ–Ω: " << result.coefficients[0] << "\r\n";
            for (size_t i = 0; i < significantIndices.size(); i++) {
                int originalIdx = selectedColumns[significantIndices[i]];
                if (originalIdx < (int)columnNames.size()) {
                    ss << columnNames[originalIdx] << ": " << result.coefficients[i + 1] << "\r\n";
                }
            }

            ss << "\r\n–ú–ï–¢–†–ò–ö–ò –ö–ê–ß–ï–°–¢–í–ê:\r\n";
            ss << "R¬≤ (–∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –¥–µ—Ç–µ—Ä–º–∏–Ω–∞—Ü–∏–∏): " << result.r_squared << "\r\n";
            ss << "MAPE (—Å—Ä–µ–¥–Ω—è—è –∞–±—Å–æ–ª—é—Ç–Ω–∞—è –ø—Ä–æ—Ü–µ–Ω—Ç–Ω–∞—è –æ—à–∏–±–∫–∞): " << result.mape << "%\r\n";

            ss << "\r\n–û–¶–ï–ù–ö–ê –ö–ê–ß–ï–°–¢–í–ê:\r\n";
            if (result.r_squared > 0.7) {
                ss << "[‚úì] R¬≤ > 0.7 - –•–æ—Ä–æ—à–µ–µ –∫–∞—á–µ—Å—Ç–≤–æ –º–æ–¥–µ–ª–∏\r\n";
            }
            else {
                ss << "[‚úó] R¬≤ ‚â§ 0.7 - –ù–∏–∑–∫–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ –º–æ–¥–µ–ª–∏\r\n";
            }

            if (result.mape < 10.0) {
                ss << "[‚úì] MAPE < 10% - –•–æ—Ä–æ—à–∞—è —Ç–æ—á–Ω–æ—Å—Ç—å –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–π\r\n";
            }
            else {
                ss << "[‚úó] MAPE ‚â• 10% - –ù–∏–∑–∫–∞—è —Ç–æ—á–Ω–æ—Å—Ç—å –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–π\r\n";
            }

            ss << "\r\n–£–†–ê–í–ù–ï–ù–ò–ï –†–ï–ì–†–ï–°–°–ò–ò:\r\n";
            ss << "y = " << result.coefficients[0];
            for (size_t i = 0; i < significantIndices.size(); i++) {
                int originalIdx = selectedColumns[significantIndices[i]];
                if (originalIdx < (int)columnNames.size()) {
                    double coeff = result.coefficients[i + 1];
                    if (coeff >= 0) {
                        ss << " + " << coeff << " √ó " << columnNames[originalIdx];
                    }
                    else {
                        ss << " + (" << coeff << ") √ó " << columnNames[originalIdx];
                    }
                }
            }
            ss << "\r\n\r\n";
        }

        ss << "–î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–ê–Ø –ò–ù–§–û–†–ú–ê–¶–ò–Ø:\r\n";
        ss << "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–Ω–∞—á–∏–º—ã—Ö –ø—Ä–∏–∑–Ω–∞–∫–æ–≤: " << significantIndices.size() << "\r\n";
        ss << "–ò—Å—Ö–æ–¥–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–∏–∑–Ω–∞–∫–æ–≤: " << features.size() << "\r\n";

        resultsText = ss.str();
        std::wstring wResultsText = StringToWString(resultsText);
        SetWindowText(hResultsEdit, wResultsText.c_str());

        MessageBox(hMainWindow, L"–†–∞—Å—á–µ—Ç –∑–∞–≤–µ—Ä—à–µ–Ω —É—Å–ø–µ—à–Ω–æ!", L"–£—Å–ø–µ—Ö", MB_OK | MB_ICONINFORMATION);

    }
    catch (const std::exception& e) {
        std::string errorMsg = "–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—á–µ—Ç–µ: ";
        errorMsg += e.what();
        std::wstring wErrorMsg = StringToWString(errorMsg);
        MessageBox(hMainWindow, wErrorMsg.c_str(), L"–û—à–∏–±–∫–∞", MB_OK | MB_ICONERROR);
    }
}

void SaveResults() {
    if (resultsText.empty()) {
        MessageBox(hMainWindow, L"–ù–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è!", L"–û—à–∏–±–∫–∞", MB_OK | MB_ICONWARNING);
        return;
    }

    OPENFILENAME ofn;
    wchar_t szFile[260] = L"results.txt";

    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hMainWindow;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = sizeof(szFile) / sizeof(wchar_t);
    ofn.lpstrFilter = L"Text Files\0*.txt\0All Files\0*.*\0";
    ofn.nFilterIndex = 1;
    ofn.lpstrDefExt = L"txt";
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;

    if (GetSaveFileName(&ofn)) {
        std::string filename = WStringToString(szFile);
        std::ofstream file(filename);
        if (file.is_open()) {
            file << resultsText;
            file.close();
            MessageBox(hMainWindow, L"–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã!", L"–£—Å–ø–µ—Ö", MB_OK | MB_ICONINFORMATION);
        }
        else {
            MessageBox(hMainWindow, L"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ñ–∞–π–ª–∞!", L"–û—à–∏–±–∫–∞", MB_OK | MB_ICONERROR);
        }
    }
}

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–æ–æ–±—â–µ–Ω–∏–π –æ–∫–Ω–∞
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    switch (uMsg) {
    case WM_CREATE: {
        // –ü–æ–ª—É—á–∞–µ–º —Ä–∞–∑–º–µ—Ä—ã —ç–∫—Ä–∞–Ω–∞ –¥–ª—è –∞–¥–∞–ø—Ç–∏–≤–Ω–æ–≥–æ –¥–∏–∑–∞–π–Ω–∞
        RECT screenRect;
        GetClientRect(hwnd, &screenRect);
        int screenWidth = screenRect.right;
        int screenHeight = screenRect.bottom;

        // –ó–∞–≥–æ–ª–æ–≤–æ–∫
        CreateWindow(L"STATIC", L"–ê–Ω–∞–ª–∏–∑ –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω–æ–π —Ä–µ–≥—Ä–µ—Å—Å–∏–∏",
            WS_VISIBLE | WS_CHILD | SS_CENTER,
            50, 30, screenWidth - 100, 40, hwnd, NULL, NULL, NULL);

        // –ö–Ω–æ–ø–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏
        hLoadButton = CreateWindow(L"BUTTON", L"üìÅ –ó–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ",
            WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON,
            50, 90, 200, 50, hwnd, (HMENU)ID_LOAD_BUTTON, NULL, NULL);

        // –õ–µ–≤–∞—è –∫–æ–ª–æ–Ω–∫–∞ - –≤—ã–±–æ—Ä —Å—Ç–æ–ª–±—Ü–æ–≤
        CreateWindow(L"STATIC", L"–í—ã–±–µ—Ä–∏—Ç–µ —Å—Ç–æ–ª–±—Ü—ã –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞:",
            WS_VISIBLE | WS_CHILD,
            50, 160, 250, 25, hwnd, NULL, NULL, NULL);

        hColumnList = CreateWindow(L"LISTBOX", NULL,
            WS_VISIBLE | WS_CHILD | WS_BORDER | WS_VSCROLL | LBS_MULTIPLESEL,
            50, 190, 250, 200, hwnd, (HMENU)ID_COLUMN_LIST, NULL, NULL);

        // –°—Ä–µ–¥–Ω—è—è –∫–æ–ª–æ–Ω–∫–∞ - –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
        CreateWindow(L"STATIC", L"–¶–µ–ª–µ–≤–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è:",
            WS_VISIBLE | WS_CHILD,
            320, 160, 200, 25, hwnd, NULL, NULL, NULL);

        hTargetCombo = CreateWindow(L"COMBOBOX", NULL,
            WS_VISIBLE | WS_CHILD | WS_BORDER | CBS_DROPDOWNLIST | WS_VSCROLL,
            320, 190, 200, 200, hwnd, (HMENU)ID_TARGET_COMBO, NULL, NULL);

        // –ú–µ—Ç–æ–¥—ã —Ä–µ–≥—Ä–µ—Å—Å–∏–∏ —Å –≥–∞–ª–æ—á–∫–∞–º–∏
        CreateWindow(L"STATIC", L"–ú–µ—Ç–æ–¥—ã —Ä–µ–≥—Ä–µ—Å—Å–∏–∏:",
            WS_VISIBLE | WS_CHILD,
            320, 240, 200, 25, hwnd, NULL, NULL, NULL);

        hMethodOLS = CreateWindow(L"BUTTON", L"OLS (–û–±—ã—á–Ω—ã–π –ú–ù–ö)",
            WS_VISIBLE | WS_CHILD | BS_AUTOCHECKBOX,
            320, 270, 200, 25, hwnd, (HMENU)ID_METHOD_OLS, NULL, NULL);
        SendMessage(hMethodOLS, BM_SETCHECK, BST_CHECKED, 0); // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤—ã–±—Ä–∞–Ω

        hMethodRidge = CreateWindow(L"BUTTON", L"Ridge —Ä–µ–≥—Ä–µ—Å—Å–∏—è",
            WS_VISIBLE | WS_CHILD | BS_AUTOCHECKBOX,
            320, 300, 200, 25, hwnd, (HMENU)ID_METHOD_RIDGE, NULL, NULL);

        hMethodHuber = CreateWindow(L"BUTTON", L"Huber —Ä–µ–≥—Ä–µ—Å—Å–∏—è",
            WS_VISIBLE | WS_CHILD | BS_AUTOCHECKBOX,
            320, 330, 200, 25, hwnd, (HMENU)ID_METHOD_HUBER, NULL, NULL);

        hMethodWeighted = CreateWindow(L"BUTTON", L"–í–∑–≤–µ—à–µ–Ω–Ω–∞—è —Ä–µ–≥—Ä–µ—Å—Å–∏—è",
            WS_VISIBLE | WS_CHILD | BS_AUTOCHECKBOX,
            320, 360, 200, 25, hwnd, (HMENU)ID_METHOD_WEIGHTED, NULL, NULL);

        // –ü–∞—Ä–∞–º–µ—Ç—Ä Œª —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ–º
        CreateWindow(L"STATIC", L"–ü–∞—Ä–∞–º–µ—Ç—Ä Œª (–¥–ª—è Ridge):",
            WS_VISIBLE | WS_CHILD,
            320, 400, 200, 25, hwnd, NULL, NULL, NULL);

        hLambdaEdit = CreateWindow(L"EDIT", L"0.01",
            WS_VISIBLE | WS_CHILD | WS_BORDER | ES_NUMBER,
            320, 430, 200, 30, hwnd, (HMENU)ID_LAMBDA_EDIT, NULL, NULL);

        // –ü—Ä–∞–≤–∞—è –∫–æ–ª–æ–Ω–∫–∞ - –∫–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        hCalculateButton = CreateWindow(L"BUTTON", L"üî¨ –†–∞—Å—Å—á–∏—Ç–∞—Ç—å",
            WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON,
            550, 190, 150, 50, hwnd, (HMENU)ID_CALCULATE_BUTTON, NULL, NULL);

        hSaveButton = CreateWindow(L"BUTTON", L"üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å",
            WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON,
            550, 260, 150, 50, hwnd, (HMENU)ID_SAVE_BUTTON, NULL, NULL);

        // –û–±–ª–∞—Å—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ (–∑–∞–Ω–∏–º–∞–µ—Ç –≤—Å—é –Ω–∏–∂–Ω—é—é —á–∞—Å—Ç—å)
        CreateWindow(L"STATIC", L"–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∞–Ω–∞–ª–∏–∑–∞:",
            WS_VISIBLE | WS_CHILD,
            50, 480, 200, 25, hwnd, NULL, NULL, NULL);

        hResultsEdit = CreateWindow(L"EDIT", L"",
            WS_VISIBLE | WS_CHILD | WS_BORDER | WS_VSCROLL | WS_HSCROLL |
            ES_MULTILINE | ES_READONLY,
            50, 510, screenWidth - 100, screenHeight - 560, hwnd, (HMENU)ID_RESULTS_EDIT, NULL, NULL);

        break;
    }

    case WM_COMMAND: {
        switch (LOWORD(wParam)) {
        case ID_LOAD_BUTTON:
            LoadFile();
            break;
        case ID_CALCULATE_BUTTON:
            CalculateRegression();
            break;
        case ID_SAVE_BUTTON:
            SaveResults();
            break;
        }
        break;
    }

    case WM_CTLCOLORSTATIC: {
        HDC hdc = (HDC)wParam;
        SetBkColor(hdc, RGB(240, 248, 255));
        SetTextColor(hdc, RGB(25, 25, 112));
        return (LRESULT)CreateSolidBrush(RGB(240, 248, 255));
    }

    case WM_CTLCOLOREDIT: {
        HDC hdc = (HDC)wParam;
        SetBkColor(hdc, RGB(255, 255, 255));
        SetTextColor(hdc, RGB(0, 0, 0));
        return (LRESULT)CreateSolidBrush(RGB(255, 255, 255));
    }

    case WM_CTLCOLORLISTBOX: {
        HDC hdc = (HDC)wParam;
        SetBkColor(hdc, RGB(248, 248, 255));
        SetTextColor(hdc, RGB(0, 0, 0));
        return (LRESULT)CreateSolidBrush(RGB(248, 248, 255));
    }

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return 0;
}

// –ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
    SetConsoleCP(CP_UTF8);
    SetConsoleOutputCP(CP_UTF8);

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –æ–±—â–∏—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
    InitCommonControls();

    // –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∫–ª–∞—Å—Å–∞ –æ–∫–Ω–∞
    const wchar_t* CLASS_NAME = L"RegressionAnalyzer";

    WNDCLASS wc = {};
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = CLASS_NAME;
    wc.hbrBackground = CreateSolidBrush(RGB(240, 248, 255));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);

    RegisterClass(&wc);

    // –ü–æ–ª—É—á–∞–µ–º —Ä–∞–∑–º–µ—Ä—ã —ç–∫—Ä–∞–Ω–∞ –¥–ª—è –ø–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞
    int screenWidth = GetSystemMetrics(SM_CXSCREEN);
    int screenHeight = GetSystemMetrics(SM_CYSCREEN);

    // –°–æ–∑–¥–∞–Ω–∏–µ –≥–ª–∞–≤–Ω–æ–≥–æ –æ–∫–Ω–∞ –≤ –ø–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω–æ–º —Ä–µ–∂–∏–º–µ
    hMainWindow = CreateWindowEx(
        0,
        CLASS_NAME,
        L"–ê–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω–æ–π —Ä–µ–≥—Ä–µ—Å—Å–∏–∏ v2.0",
        WS_OVERLAPPEDWINDOW | WS_MAXIMIZE, // –î–æ–±–∞–≤–ª—è–µ–º WS_MAXIMIZE –¥–ª—è –ø–æ–ª–Ω–æ–≥–æ —ç–∫—Ä–∞–Ω–∞
        0, 0, screenWidth, screenHeight,   // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä—ã –Ω–∞ –≤–µ—Å—å —ç–∫—Ä–∞–Ω
        NULL, NULL, hInstance, NULL
    );

    if (hMainWindow == NULL) {
        return 0;
    }

    ShowWindow(hMainWindow, SW_MAXIMIZE); // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≤ –º–∞–∫—Å–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–º —Ä–µ–∂–∏–º–µ
    UpdateWindow(hMainWindow);

    // –¶–∏–∫–ª —Å–æ–æ–±—â–µ–Ω–∏–π
    MSG msg = {};
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return 0;
}
